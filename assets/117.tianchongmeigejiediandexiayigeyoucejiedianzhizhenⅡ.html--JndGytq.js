import{_ as n,o as s,c as a,f as e}from"./app-GYMnAgnr.js";const t="/viteblog/assets/117_sample-QstzITT2.png",o={},p=e(`<p><strong>难度：中等</strong></p><p>给定一个二叉树，其定义如下：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> val<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token class-name">Node</span> left<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token class-name">Node</span> right<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token class-name">Node</span> next<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 <code>NULL</code>。</p><p>初始状态下，所有 next 指针都被设置为 <code>NULL</code>。</p><p><strong>示例 1：</strong></p><p><img src="`+t+`" alt="img"></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>输入：root = [1,2,3,4,5,null,7]
输出：[1,#,2,3,#,4,5,7,#]
解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化输出按层序遍历顺序（由 next 指针连接），&#39;#&#39; 表示每层的末尾。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 2：</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>输入：root = []
输出：[]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>提示：</strong></p><ul><li>树中的节点数在范围 <code>[0, 6000]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><p><strong>进阶：</strong></p><ul><li>你只能使用常量级额外空间。</li><li>使用递归解题也符合要求，本题中递归程序的隐式栈空间不计入额外空间复杂度。</li></ul><h2 id="层序遍历-队列法" tabindex="-1"><a class="header-anchor" href="#层序遍历-队列法" aria-hidden="true">#</a> 层序遍历+队列法</h2><p><strong>这道题和 102 题非常类似，只不过在单层遍历的时候需要使用虚拟头节点，并记录前一个节点，在遍历的时候让前一个节点的 <code>next</code> 指针指向本节点就可以了。</strong></p><p>层序遍历一个二叉树。就是从左到右、一层一层地去遍历二叉树。这种遍历的方式需要借用一个辅助数据结构即队列来实现。</p><p>队列具有 <strong>先进先出</strong> 的特性，符合层序遍历的逻辑。这种层序遍历的方式就是图论中的广度优先遍历，只不过我们应用在了二叉树上。</p><p>算法流程：</p><ol><li><p><strong>处理特例</strong>：若根节点为空，则返回空</p></li><li><p><strong>根节点入队</strong></p></li><li><p><strong>BFS 循环</strong>： 判断队列是否为空。如果不为空，说明还有节点需要遍历</p><ol><li>初始化当前层的节点个数 <code>currentLevelSize</code> 为队列的大小。</li><li>使用一个虚拟头节点来实现统一操作，同时设定一个 <code>previous</code> 指针指向前一个节点</li><li>使用一个内层循环，遍历当前层的节点。循环次数为当前层的节点个数 <code>currentLevelSize</code>。 <ol><li>从队列中取出一个节点 <code>current</code>，让 <code>previous</code> 节点的 <code>next</code> 指向当前节点，并使 <code>previous</code> 指针指向当前节点</li><li>如果当前节点有左子节点，将左子节点入队。</li><li>如果当前节点有右子节点，将右子节点入队。</li></ol></li><li>此时队列中已经把当前层的节点都出队了，同时把下一层的节点都入队了，因此队列大小刚好变成了下一层的节点个数。</li></ol></li><li><p><strong>返回根节点</strong>：当所有层都遍历完毕后，返回原始的根节点 <code>root</code>。此时，树中的每个节点都已正确设置了<code>next</code>指针。</p></li></ol><h2 id="代码展示" tabindex="-1"><a class="header-anchor" href="#代码展示" aria-hidden="true">#</a> 代码展示</h2><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">Node</span> <span class="token function">connect</span><span class="token punctuation">(</span><span class="token class-name">Node</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 若根节点为空，则返回空</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token class-name">Deque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 根节点入队</span>
    queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// BFS 循环</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> currentLayerSize <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 使用虚拟头节点来实现统一操作</span>
        <span class="token class-name">Node</span> dummy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Node</span> previous <span class="token operator">=</span> dummy<span class="token punctuation">;</span>
        <span class="token comment">// 这里一定要使用固定大小currentLayerSize，不要使用queue.size()，因为queue不停地出队入队，所以其大小是不断变化的</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> currentLayerSize<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">Node</span> current <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            previous<span class="token punctuation">.</span>next <span class="token operator">=</span> current<span class="token punctuation">;</span>
            previous <span class="token operator">=</span> current<span class="token punctuation">;</span>

            <span class="token keyword">if</span> <span class="token punctuation">(</span>current<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>current<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>current<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>current<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> root<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>时间复杂度：O(n)，其中 n 是二叉树的节点数。每一个节点恰好被遍历一次。</p><p>空间复杂度：O(n)，最差情况下，即当树为满二叉树时，最多有 (n+1)/2 个树节点 <strong>同时</strong> 在 <code>queue</code> 中，故使用 O(n) 大小的额外空间。</p><h2 id="层序遍历-链表法" tabindex="-1"><a class="header-anchor" href="#层序遍历-链表法" aria-hidden="true">#</a> 层序遍历+链表法</h2><p>在上述做法中，我们通过队列来获取当前层的所有节点，同时在每一层节点的遍历过程中做了两件事：</p><ol><li>给当前层的节点进行 <code>next</code> 指针的连接</li><li>使用队列来存储下一层的所有节点，方便下一层的节点遍历过程</li></ol><p>这样做时间复杂度为O(n)，然而实际上，一旦在某层的节点之间建立了 <code>next</code> 指针，那这层节点就形成了一个链表。</p><p>也就是说：</p><ol><li>如果第 i 层节点之间已经建立了 <code>next</code> 指针，就可以通过 <code>next</code> 指针访问该层的所有节点，而不用再使用队列。</li><li>同时对于每个第 i 层的节点，我们又可以通过它的 <code>left</code> 和 <code>right</code> 指针知道其第 i+1 层的孩子节点是什么，所以遍历过程中就能够按顺序为第 i+1 层节点建立起 <code>next</code> 指针。</li></ol><p>算法流程：</p><ol><li><strong>处理特例</strong>：若根节点为空，则返回空</li><li><strong>设置当前节点</strong>：算法初始化时，设置当前节点 <code>current</code> 为根节点 <code>root</code>。这个 <code>current</code> 指针用于遍历树的每一层</li><li><strong>BFS 循环</strong>： 外层循环的作用是遍历树的每一层。只要 <code>current</code> 不为 <code>null</code>，就表示还有更多的层需要遍历 <ol><li>对于每一层，首先创建一个虚拟头节点 <code>dummy</code>，这个节点用于从而减少一些关于空节点的判断逻辑</li><li><code>dummy.next</code> 初始化为 <code>null</code>，同时设定一个 <code>nextLayerPrevious</code> 指针指向下一层节点的前一个节点，初始化为 <code>dummy</code></li><li>使用一个内层循环，利用当前层节点的 <code>next</code> 指针来遍历当前层的每个节点。 <ol><li>如果当前节点的左子节点不为空，则将左子节点连接到 <code>nextLayerPrevious.next</code>，这样可以确保左子节点是下一层的第一个节点。同理，如果右子节点不为空，也进行相同的操作。在连接过程中，<code>nextLayerPrevious</code> 不断向前移动，以保证正确连接下一层的所有节点。</li><li>完成当前层的遍历后，将 <code>current</code> 设置为 <code>dummy.next</code>，即下一层的第一个节点，然后继续执行外层循环。</li></ol></li></ol></li><li><strong>返回根节点</strong>：当所有层都遍历完毕后，返回原始的根节点 <code>root</code>。此时，树中的每个节点都已正确设置了<code>next</code>指针。</li></ol><h2 id="代码展示-1" tabindex="-1"><a class="header-anchor" href="#代码展示-1" aria-hidden="true">#</a> 代码展示</h2><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">Node</span> <span class="token function">connect</span><span class="token punctuation">(</span><span class="token class-name">Node</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 若根节点为空，则返回空</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token class-name">Node</span> current <span class="token operator">=</span> root<span class="token punctuation">;</span>
    <span class="token comment">// BFS 循环</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>current <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 虚拟头节点</span>
        <span class="token class-name">Node</span> dummy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        dummy<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token class-name">Node</span> nextLayerPrevious <span class="token operator">=</span> dummy<span class="token punctuation">;</span>
        <span class="token comment">// 遍历当前层节点，为下一层节点填充next指针</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>current <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>current<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                nextLayerPrevious<span class="token punctuation">.</span>next <span class="token operator">=</span> current<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
                nextLayerPrevious <span class="token operator">=</span> nextLayerPrevious<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>current<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                nextLayerPrevious<span class="token punctuation">.</span>next <span class="token operator">=</span> current<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
                nextLayerPrevious <span class="token operator">=</span> nextLayerPrevious<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            current <span class="token operator">=</span> current<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        current <span class="token operator">=</span> dummy<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> root<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>时间复杂度：O(n)，其中 n 是二叉树的节点数。每一个节点恰好被遍历一次。</p><p>空间复杂度：O(1)，因为这种做法没有使用队列，所以大大降低了空间复杂度。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p><strong>这份代码可以作为二叉树层序遍历的模板。</strong></p><p><strong>善用虚拟头节点能解决很多麻烦。</strong></p>`,39),c=[p];function l(i,u){return s(),a("div",null,c)}const d=n(o,[["render",l],["__file","117.tianchongmeigejiediandexiayigeyoucejiedianzhizhenⅡ.html.vue"]]);export{d as default};
