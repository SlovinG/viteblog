import{_ as n,o as s,c as a,f as e}from"./app-GYMnAgnr.js";const t="/viteblog/assets/rev1ex1-Q34OTktd.jpg",p="/viteblog/assets/rev1ex2-NUtW1AW7.jpg",c={},o=e('<p><strong>难度：简单</strong></p><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p><p><strong>示例 1：</strong></p><p><img src="'+t+`" alt="img"></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>输入：head = [1,2,3,4,5]
输出：[5,4,3,2,1]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 2：</strong></p><p><img src="`+p+`" alt="img"></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>输入：head = [1,2]
输出：[2,1]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 3：</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>输入：head = []
输出：[]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>提示：</strong></p><ul><li>链表中节点的数目范围是 <code>[0, 5000]</code></li><li><code>-5000 &lt;= Node.val &lt;= 5000</code></li></ul><p>**进阶：**链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？</p><h2 id="解题思路" tabindex="-1"><a class="header-anchor" href="#解题思路" aria-hidden="true">#</a> 解题思路</h2><p>数组支持 <strong>随机访问</strong>（Random Access），随机访问这个概念在计算机科学中被定义为：<strong>可以用同等的时间访问到一组数据中的任意一个元素</strong>。</p><p>而链表显然是不满足这个特性的。</p><p>数组反转的常见方法是：第一个元素与最后一个元素互换位置，索引持续往中间逼近，重复这个操作即可。</p><p>那么针对链表的反转操作，关键点在于让每个节点的 next 指向自己的 pre 节点。</p><p><strong>如果再定义一个新的链表，来实现对链表元素的反转，则是对内存空间的浪费。</strong></p><p>我的思路：</p><ol><li>从头节点开始遍历，获取当前节点、pre 节点、next 节点 <ol><li>让当前节点的 next 指向 pre</li><li>当前节点 = next 节点</li></ol></li><li>到达链表尾的时候，退出循环</li></ol><h2 id="我的代码-迭代法" tabindex="-1"><a class="header-anchor" href="#我的代码-迭代法" aria-hidden="true">#</a> 我的代码（迭代法）</h2><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token class-name">ListNode</span> <span class="token function">reverseList</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> head<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">ListNode</span> pre <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  <span class="token comment">// 前一个节点</span>
        <span class="token class-name">ListNode</span> cur <span class="token operator">=</span> head<span class="token punctuation">;</span>  <span class="token comment">// 当前处理的节点</span>
        <span class="token class-name">ListNode</span> next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 保存cur的下一个节点</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            next <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span> <span class="token comment">// 保存下一个节点</span>
            cur<span class="token punctuation">.</span>next <span class="token operator">=</span> pre<span class="token punctuation">;</span>  <span class="token comment">// 将当前节点的next指向前一个节点，实现反转</span>
            pre <span class="token operator">=</span> cur<span class="token punctuation">;</span>       <span class="token comment">// 更新前一个节点为当前节点</span>
            cur <span class="token operator">=</span> next<span class="token punctuation">;</span>      <span class="token comment">// 移动到下一个节点</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 当循环结束时，pre 将指向新的头节点</span>
        <span class="token keyword">return</span> pre<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>时间复杂度：O(n)</p><p>空间复杂度：O(1)</p><h2 id="递归法" tabindex="-1"><a class="header-anchor" href="#递归法" aria-hidden="true">#</a> 递归法</h2><p>递归法相对抽象一些，但是其实和迭代法是一样的逻辑，同样是当 cur 为空的时候递归结束，不断将 cur.next 指向 pre 的过程。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token class-name">ListNode</span> <span class="token function">reverseList</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> head<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">reverse</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> head<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">ListNode</span> <span class="token function">reverse</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> pre<span class="token punctuation">,</span> <span class="token class-name">ListNode</span> cur<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 递归出口</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>cur <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> pre<span class="token punctuation">;</span>
        <span class="token comment">// 递归部分</span>
        <span class="token class-name">ListNode</span> next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 保存cur的下一个节点</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            next <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
            cur<span class="token punctuation">.</span>next <span class="token operator">=</span> pre<span class="token punctuation">;</span><span class="token comment">// 反转操作</span>
            pre <span class="token operator">=</span> cur<span class="token punctuation">;</span>
            cur <span class="token operator">=</span> next<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token function">reverse</span><span class="token punctuation">(</span>pre<span class="token punctuation">,</span> cur<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>时间复杂度: O(n)，要递归处理链表的每个节点</p><p>空间复杂度: O(n)，递归调用了 n 层栈空间</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>如果使用 C，C++ 编程语言的话，不要忘了还要从内存中删除这两个移除的节点。</p><p><strong>当然如果使用 Java ，Python 的话就不用手动管理内存了。</strong></p><p>注意虚拟头节点的引入，可以使代码逻辑更统一。</p>`,34),l=[o];function i(r,u){return s(),a("div",null,l)}const k=n(c,[["render",i],["__file","206.fanzhuanlianbiao.html.vue"]]);export{k as default};
