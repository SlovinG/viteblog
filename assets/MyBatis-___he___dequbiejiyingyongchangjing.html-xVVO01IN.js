import{_ as s,o as a,c as e,a as n,f as o}from"./app-GYMnAgnr.js";const p={},t=o(`<p>动态 sql 是 Mybatis 的主要特性之一，在 mapper 中定义的参数传到 xml 中之后，在查询之前 Mybatis 会对其进行动态解析</p><p>Mybatis 提供了两种支持动态 sql 的语法：#{} 、\${}</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t_user <span class="token keyword">where</span> username <span class="token operator">=</span> <span class="token string">&#39;\${username}&#39;</span><span class="token punctuation">;</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t_user <span class="token keyword">where</span> username <span class="token operator">=</span> <span class="token comment">#{username};</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>username 传参一致的话,这两种执行的结果是一样的，但是这两种方式在动态 sql 解析阶段的处理是不一样的</p><h2 id="" tabindex="-1"><a class="header-anchor" href="#" aria-hidden="true">#</a> #{}</h2><p><strong>#{变量名}</strong> 会进行预编译、类型匹配等操作，传入参数会转化为 jdbc 的类型。</p><p>例如：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tablename <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token comment">#{id}；</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>假设 id 的值为12，其中如果数据库字段 id 为字符型，那么 <code>#{id}</code>表示的就是<code>&#39;12&#39;</code>，如果id为整型，那么id就是 <code>12</code>。</p><p>MyBatis会将 <code>#{id}</code> 解析为一个 JDBC 预编译语句的参数标记符，把参数部分用占位符<code>?</code>代替。动态解析为：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tablename <span class="token keyword">where</span> id <span class="token operator">=</span> ?；
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>而传入的参数将会经过 <code>PreparedStatement</code> 方法的强制类型检查和安全检查等处理，最后作为一个合法的字符串传入。</p><h2 id="-1" tabindex="-1"><a class="header-anchor" href="#-1" aria-hidden="true">#</a> \${}</h2><p><strong>\${变量名}</strong> 不会进行数据类型匹配，直接替换。</p><p>例如：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tablename <span class="token keyword">where</span> id <span class="token operator">=</span> \${id}；
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果字段id为整型，sql语句就不会出错，但是如果字段id为字符型， 那么sql语句应该写成</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">table</span> <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token string">&#39;\${id}&#39;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>MyBatis只会做简单的字符串替换，在动态SQL解析阶段将会进行变量替换，动态解析为：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tablename <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">12</span>；
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="二者的对比" tabindex="-1"><a class="header-anchor" href="#二者的对比" aria-hidden="true">#</a> 二者的对比</h2><p><strong>#{变量名}</strong> 预处理之后可以预防 SQL 注入，而 <strong>\${变量名}</strong> 在预编译之前就已经被替换，有被注入的风险</p><p>如果传入的 <strong>username</strong> 为 <strong>a&#39; or &#39;1=1</strong>，那么使用 \${} 处理后直接替换字符串的 sql 就解析为：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t_user <span class="token keyword">where</span> username <span class="token operator">=</span> a<span class="token string">&#39; or &#39;</span><span class="token number">1</span><span class="token operator">=</span><span class="token number">1</span>&#39; <span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这样的话所有的用户数据就被查出来了，这样就属于 SQL 注入。</p><p>如果使用 <code>#{}</code>，经过sql动态解析和预编译，会把单引号转义为 <code>\\&#39;</code> 那么sql最终解析为：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t_user <span class="token keyword">where</span> username <span class="token operator">=</span> <span class="token string">&quot;a\\&#39; or \\&#39;1=1 &quot;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这样会查不出任何数据，有效阻止sql注入。</p><p>有的业务场景经常用到模糊查询，也就是 like 处理，推荐使用以下处理方式：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code>t_user<span class="token punctuation">.</span>username <span class="token operator">like</span> <span class="token comment">#username#</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>java代码里：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token class-name">StringUtil</span><span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>username<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	table<span class="token punctuation">.</span><span class="token function">setUsername</span><span class="token punctuation">(</span><span class="token string">&quot;%&quot;</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>username <span class="token operator">+</span> <span class="token string">&quot;%&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>或者也可以使用数据库函数进行连接处理：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t_user u <span class="token keyword">where</span> username <span class="token operator">like</span> CONCAT<span class="token punctuation">(</span><span class="token string">&#39;%&#39;</span><span class="token punctuation">,</span> <span class="token comment">#username#, &#39;%&#39;);</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="只可使用-变量名-的场景" tabindex="-1"><a class="header-anchor" href="#只可使用-变量名-的场景" aria-hidden="true">#</a> 只可使用\${变量名}的场景</h2><p>如 order by 后的 <code>排序字段</code>，<code>表名</code>、<code>列名</code>,因为需要替换为不变的常量，则只可使用 <code>\${}</code></p><p>例：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token comment">#{tablename} where id = \${id}；</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果表名中使用 <code>#{}</code>的话传参为 <code>t_user</code>，会变成 <code>select * from &#39;t_user&#39;</code>，没有这样的表名，这样的话就会报错了，<code>order by</code> 同理。</p><h2 id="性能考虑" tabindex="-1"><a class="header-anchor" href="#性能考虑" aria-hidden="true">#</a> 性能考虑</h2><p>因为预编译语句对象可以重复利用，把一个sql预编译后产生的 <code>PreparedStatement</code> 对象缓存下来，下次对于同一个 sql，可以直接使用缓存的 <code>PreparedStatement</code> 对象，mybatis默认情况下，对所有的sql进行预编译，这样的话 <code>#{}</code> 的处理方式性能会相对高些。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><ul><li><p>能使用 #{} 的时候尽量使用 #{}</p></li><li><p>表名、order by 的排序字段作为变量时，使用\${}</p></li></ul>`,43);function l(r,d){return a(),e("div",null,[n(" more "),t])}const i=s(p,[["render",l],["__file","MyBatis-___he___dequbiejiyingyongchangjing.html.vue"]]);export{i as default};
