import{_ as n,o as s,c as a,f as o}from"./app-GYMnAgnr.js";const e="/viteblog/assets/merge-_9PlHePG.jpg",t={},p=o('<p><strong>难度：容易</strong></p><p>给你两棵二叉树： <code>root1</code> 和 <code>root2</code> 。</p><p>想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，<strong>不为</strong> null 的节点将直接作为新二叉树的节点。</p><p>返回合并后的二叉树。</p><p><strong>注意:</strong> 合并过程必须从两个树的根节点开始。</p><p><strong>示例 1：</strong></p><p><img src="'+e+`" alt="img"></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>输入：root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]
输出：[3,4,5,5,4,null,7]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 2：</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>输入：root1 = [1], root2 = [1,2]
输出：[2,2]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>提示：</strong></p><ul><li>两棵树中的节点数目在范围 <code>[0, 2000]</code> 内</li><li><code>-104 &lt;= Node.val &lt;= 104</code></li></ul><h2 id="递归法" tabindex="-1"><a class="header-anchor" href="#递归法" aria-hidden="true">#</a> 递归法</h2><p>这道题和 <strong>100.相同的树</strong> 感觉很像，都是同时要对两棵树进行操作。</p><p>算法步骤：</p><ol><li><strong>检查基本条件</strong>：如果两个根节点 <code>root1</code> 和 <code>root2</code> 都为 <code>null</code>，说明两棵树在这个位置上都没有节点，因此合并后的树在这个位置上也应该没有节点，直接返回 <code>null</code>。</li><li><strong>单一非空树的处理</strong>： <ul><li>如果 <code>root1</code> 为 <code>null</code> 而 <code>root2</code> 不为 <code>null</code>，说明只有第二棵树在这个位置上有节点，直接返回 <code>root2</code> 作为合并后的节点。</li><li>同理，如果 <code>root1</code> 不为 <code>null</code> 而 <code>root2</code> 为 <code>null</code>，直接返回 <code>root1</code>。</li></ul></li><li><strong>合并节点值</strong>：如果两个根节点都不为空，创建一个新的树节点<code>root</code>，其值为 <code>root1</code> 和 <code>root2</code> 节点值的和（<code>root1.val + root2.val</code>）。</li><li><strong>递归合并左右子树</strong>： <ul><li>对 <code>root1</code> 和 <code>root2</code> 的左子节点递归调用 <code>mergeTrees</code> 函数，将返回值设置为新树 <code>root</code> 的左子节点。</li><li>对 <code>root1</code> 和 <code>root2</code> 的右子节点递归调用 <code>mergeTrees</code> 函数，将返回值设置为新树 <code>root</code> 的右子节点。</li></ul></li><li><strong>返回合并后的树的根节点</strong>：递归处理完所有节点后，返回新创建的树的根节点 <code>root</code>。</li></ol><h2 id="代码展示" tabindex="-1"><a class="header-anchor" href="#代码展示" aria-hidden="true">#</a> 代码展示</h2><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">TreeNode</span> <span class="token function">mergeTrees</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root1<span class="token punctuation">,</span> <span class="token class-name">TreeNode</span> root2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root1 <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> root2 <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root1 <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> root2 <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> root2<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root1 <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> root2 <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> root1<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token class-name">TreeNode</span> root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>root1<span class="token punctuation">.</span>val <span class="token operator">+</span> root2<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
    root<span class="token punctuation">.</span>left<span class="token operator">=</span><span class="token function">mergeTrees</span><span class="token punctuation">(</span>root1<span class="token punctuation">.</span>left<span class="token punctuation">,</span>root2<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
    root<span class="token punctuation">.</span>right<span class="token operator">=</span><span class="token function">mergeTrees</span><span class="token punctuation">(</span>root1<span class="token punctuation">.</span>right<span class="token punctuation">,</span>root2<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> root<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>时间复杂度：O(n)，其中 n 是二叉树的节点数。每一个节点恰好被遍历一次。</p><p>空间复杂度：O(1)，因为这种做法没有使用队列，所以大大降低了空间复杂度。</p><h2 id="队列迭代法" tabindex="-1"><a class="header-anchor" href="#队列迭代法" aria-hidden="true">#</a> 队列迭代法</h2><p>首先我们引入队列，这是把递归程序改写成迭代程序的常用方法。</p><p>使用一个队列，并成对地将两棵树的节点加入队列，然后逐一比较这些节点的值。</p><p>算法的核心逻辑：</p><ol><li><strong>边界条件处理</strong>：如果 <code>root1 </code>或 <code>root2</code> 中的任意一个为<code>null</code>，直接返回另一个节点。这意味着如果有一棵树为空，合并后的树就是另一棵树。</li><li><strong>使用队列进行层序遍历</strong>：初始化一个队列 <code>queue</code>，并将两棵树的根节点作为一对节点加入队列。这个队列用于存储待合并的节点对。</li><li><strong>迭代合并</strong>：在队列不为空的情况下，循环执行以下操作： <ul><li>从队列中弹出两个节点 <code>node1</code> 和 <code>node2</code>。由于之前的判断，这两个节点都不会是 <code>null</code>。</li><li>将 <code>node2</code> 的值加到 <code>node1</code>上，实现节点值的合并。</li><li>接下来检查这两个节点的左子节点和右子节点： <ul><li>如果 <code>node1</code> 和 <code>node2</code> 的左子节点都不为 <code>null</code>，则将它们加入队列以待后续合并。</li><li>如果 <code>node1</code> 的左子节点为 <code>null</code> 而 <code>node2</code> 的左子节点不为 <code>null</code>，则直接将 <code>node2</code> 的左子节点赋给 <code>node1</code> 的左子节点。</li><li>对于右子节点的处理逻辑与左子节点相同。</li></ul></li></ul></li><li><strong>返回合并后的树</strong>：当队列为空，即所有节点对都已处理完毕时，返回合并后的树的根节点 <code>root1</code>。</li></ol><h2 id="代码展示-1" tabindex="-1"><a class="header-anchor" href="#代码展示-1" aria-hidden="true">#</a> 代码展示</h2><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">TreeNode</span> <span class="token function">mergeTrees</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root1<span class="token punctuation">,</span> <span class="token class-name">TreeNode</span> root2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果其中一棵树为空，则直接返回另一棵树</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root1 <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> root2<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root2 <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> root1<span class="token punctuation">;</span>

    <span class="token comment">// 使用一个队列存储节点，成对地将节点加入队列</span>
    <span class="token class-name">Deque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">&gt;</span></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 成对地将根节点加入队列</span>
    queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root2<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 每次取出两个节点进行比较</span>
        <span class="token class-name">TreeNode</span> node1 <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">TreeNode</span> node2 <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 此时两个节点一定不为空，val相加</span>
        node1<span class="token punctuation">.</span>val <span class="token operator">+=</span> node2<span class="token punctuation">.</span>val<span class="token punctuation">;</span>

        <span class="token comment">// 如果两棵树左节点都不为空，加入队列</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>node1<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> node2<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node1<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
            queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node2<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 如果两棵树右节点都不为空，加入队列</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>node1<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> node2<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node1<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
            queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node2<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 当node1的左节点为空,node2左节点不为空，就赋值过去</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>node1<span class="token punctuation">.</span>left <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> node2<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            node1<span class="token punctuation">.</span>left <span class="token operator">=</span> node2<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 当node1的右节点为空,node2右节点不为空，就赋值过去</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>node1<span class="token punctuation">.</span>right <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> node2<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            node1<span class="token punctuation">.</span>right <span class="token operator">=</span> node2<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 返回合并后的树的根节点</span>
    <span class="token keyword">return</span> root1<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>时间复杂度：O(n)，其中 n 是二叉树的节点数。每一个节点恰好被遍历一次。</p><p>空间复杂度：O(n)，最差情况下，即当树为满二叉树时，最多有 (n+1)/2 个树节点 <strong>同时</strong> 在 <code>queue</code> 中，故使用 O(n) 大小的额外空间。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>通过迭代地合并节点对，这个算法有效地将两棵树合并成一棵新树。</p><p>使用队列进行层序遍历确保了每一层的节点都被适时地合并。对于每一对节点，通过直接修改<code>node1</code>来实现合并，这样避免了创建新节点，同时也保证了合并后的树仍然保持二叉树的结构。</p>`,32),c=[p];function l(i,u){return s(),a("div",null,c)}const r=n(t,[["render",l],["__file","617.hebingerchashu.html.vue"]]);export{r as default};
