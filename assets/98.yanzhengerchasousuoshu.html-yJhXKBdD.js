import{_ as n,o as s,c as a,f as e}from"./app-GYMnAgnr.js";const o="/viteblog/assets/tree1-1709277867186-1-YjB5n_31.jpg",p="/viteblog/assets/tree2-1709437495637-33-sIxxU5H5.jpg",t={},c=e('<p><strong>难度：中等</strong></p><p>给你一个二叉树的根节点 <code>root</code> ，判断其是否是一个有效的二叉搜索树。</p><p><strong>有效</strong> 二叉搜索树定义如下：</p><ul><li>节点的左子树只包含 <strong>小于</strong> 当前节点的数。</li><li>节点的右子树只包含 <strong>大于</strong> 当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树。</li></ul><p><strong>示例 1：</strong></p><p><img src="'+o+`" alt="img"></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>输入：root = [2,1,3]
输出：true
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 2：</strong></p><p><img src="`+p+`" alt="img"></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>输入：root = [5,1,4,null,null,3,6]
输出：false
解释：根节点的值是 5 ，但是右子节点的值是 4 。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>提示：</strong></p><ul><li>树中节点数目范围在<code>[1, 10^4]</code> 内</li><li><code>-2^31 &lt;= Node.val &lt;= 2^31 - 1</code></li></ul><h2 id="递归法" tabindex="-1"><a class="header-anchor" href="#递归法" aria-hidden="true">#</a> 递归法</h2><p>二叉搜索树是一个有序树：</p><ul><li>若它的左子树不空，则左子树上所有结点的值都小于它的根结点的值；</li><li>若它的右子树不空，则右子树上所有结点的值都大于它的根结点的值；</li><li>它的左、右子树也分别为二叉搜索树</li></ul><p>这启示我们设计一个递归函数 <code>isValid(root, lower, upper)</code> 来递归判断，函数表示考虑以 <code>root</code> 为根的子树，判断子树中所有节点的值是否都在 <code>(l,r)</code>的范围内（注意是开区间）。如果 <code>root</code> 节点的值 <code>val</code> 不在 <code>(l,r)</code> 的范围内说明不满足条件直接返回，否则我们要继续递归调用检查它的左右子树是否满足，如果都满足才说明这是一棵二叉搜索树。</p><p>那么根据二叉搜索树的性质，在递归调用左子树时，我们需要把上界 <code>upper</code> 改为 <code>root.val</code>，即调用 <code>isValid(root.left, lower, root.val)</code>，因为左子树里所有节点的值均小于它的根节点的值。同理递归调用右子树时，我们需要把下界 <code>lower</code> 改为 <code>root.val</code>，即调用 <code>isValid(root.right, root.val, upper)</code>。</p><p>函数递归调用的入口为 <code>isValid(root, -inf, +inf)</code>， <code>inf</code> 表示一个无穷大的值。</p><p>算法步骤：</p><ol><li><strong>递归的基本情况</strong>：如果当前节点是<code>null</code>，根据二叉搜索树的定义，空树是有效的二叉搜索树，因此返回<code>true</code>。</li><li><strong>检查当前节点的值</strong>：如果当前节点的值不满足二叉搜索树的性质（即，不在其允许的值范围<code>lower</code>和<code>upper</code>之间），则返回<code>false</code>。具体来说，当前节点的值必须大于其允许的最小值 <code>lower</code> 并且小于其允许的最大值 <code>upper</code>。</li><li><strong>递归检查左右子树</strong>： <ul><li>对于左子树，其允许的值范围是 <code>lower</code> 到当前节点的值。递归调用 <code>isValid</code> 函数，将当前节点的值作为左子树允许的最大值。</li><li>对于右子树，其允许的值范围是当前节点的值到 <code>upper</code>。递归调用 <code>isValid</code> 函数，将当前节点的值作为右子树允许的最小值。</li></ul></li><li><strong>返回结果</strong>：如果当前节点及其所有子树都满足二叉搜索树的性质，则返回 <code>true</code>。</li></ol><h2 id="代码展示" tabindex="-1"><a class="header-anchor" href="#代码展示" aria-hidden="true">#</a> 代码展示</h2><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isValidBST</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">isValid</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token class-name">Long</span><span class="token punctuation">.</span><span class="token constant">MIN_VALUE</span><span class="token punctuation">,</span> <span class="token class-name">Long</span><span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isValid</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">,</span> <span class="token keyword">long</span> lower<span class="token punctuation">,</span> <span class="token keyword">long</span> upper<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">&lt;=</span> lower <span class="token operator">||</span> root<span class="token punctuation">.</span>val <span class="token operator">&gt;=</span> upper<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token function">isValid</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> lower<span class="token punctuation">,</span> root<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isValid</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> root<span class="token punctuation">.</span>val<span class="token punctuation">,</span> upper<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>时间复杂度：O(n)，其中n是树中的节点数。算法需要访问树中的每个节点一次。</p><p>空间复杂度：O(h)，其中h是树的高度。递归调用栈的深度由树的高度决定。在最坏的情况下（树完全倾斜），空间复杂度可以达到O(n)。</p><p><strong>为什么使用 <code>long</code> 类型</strong>：</p><p>使用 <code>long</code> 类型的 <code>Long.MIN_VALUE</code> 和 <code>Long.MAX_VALUE</code> 作为初始的上下界是为了包含 <code>int</code> 类型的所有可能值，因为二叉树节点的值是 <code>int</code> 类型的。这确保了在递归的最开始阶段，根节点的值不会因为边界问题而被错误地判断。</p><h2 id="中序遍历-递归法" tabindex="-1"><a class="header-anchor" href="#中序遍历-递归法" aria-hidden="true">#</a> 中序遍历+递归法</h2><p>核心原理：<strong>二叉搜索树是一个有序树，在中序遍历下其输出的是一个递增序列。</strong></p><p>这启示我们可以在中序遍历的时候，实时检查当前节点的值是否大于前一个中序遍历到的节点的值即可。如果一直大于，说明这个序列是升序的，整棵树是二叉搜索树，否则就不是。</p><p>算法步骤：</p><ol><li><code>prev</code> 变量用于记录中序遍历过程中访问的前一个节点。它在类的成员位置被初始化为<code>null</code>，以便在开始遍历时没有前一个节点。</li><li><code>inorder</code> 方法实现了中序遍历。它首先递归地访问左子树，然后检查当前节点是否满足BST的条件（即当前节点的值应该大于<code>prev</code>节点的值），最后递归地访问右子树。</li><li>如果在任何时候发现序列不是升序的，方法返回<code>false</code>。如果整个遍历过程中没有违反BST的条件，最终返回<code>true</code>。</li></ol><h2 id="代码展示-1" tabindex="-1"><a class="header-anchor" href="#代码展示-1" aria-hidden="true">#</a> 代码展示</h2><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">TreeNode</span> prev <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 用于记录中序遍历过程中的前一个节点</span>

<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isValidBST</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 递归进行中序遍历，并检查序列是否升序</span>
    <span class="token keyword">return</span> <span class="token function">inorder</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">inorder</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">// 空节点不违反BST的规则</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 首先递归检查左子树</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">inorder</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 如果左子树不是BST，则直接返回false</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 检查当前节点的值是否大于前一个中序遍历到的节点的值</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>prev <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> node<span class="token punctuation">.</span>val <span class="token operator">&lt;=</span> prev<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// 如果不是升序，说明不是BST</span>
    <span class="token punctuation">}</span>
    prev <span class="token operator">=</span> node<span class="token punctuation">;</span> <span class="token comment">// 更新prev为当前节点</span>

    <span class="token comment">// 然后递归检查右子树</span>
    <span class="token keyword">return</span> <span class="token function">inorder</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>时间复杂度：O(n)，其中n是树中的节点数。算法需要访问树中的每个节点恰好一次。</p><p>空间复杂度：O(h)，其中h是树的高度，对应递归调用栈的深度。在最坏的情况下（树完全倾斜），空间复杂度可以达到O(n)。</p><h2 id="中序遍历-迭代法" tabindex="-1"><a class="header-anchor" href="#中序遍历-迭代法" aria-hidden="true">#</a> 中序遍历+迭代法</h2><p>上诉中的递归函数我们也可以用迭代的方式来实现，两种方式是等价的，区别在于递归的时候隐式地维护了一个栈，而我们在迭代的时候需要显式地将这个栈模拟出来，其他都相同，具体的代码思路如下：</p><ol><li><strong>初始化</strong>：创建一个栈来保存遍历过程中的节点，以及一个 <code>prev</code> 变量来记录上一次访问的节点。初始时，<code>prev</code> 设置为 <code>null</code>。</li><li><strong>迭代遍历</strong>：使用 <code>current</code> 指针指向当前节点，初始时指向根节点 <code>root</code>。然后进入一个循环，直到 <code>current</code> 为 <code>null</code> 且栈为空。</li><li><strong>向左遍历</strong>：在循环中，首先尽可能地向左遍历，并将沿途的节点压入栈中。这一步确保了能够按照中序遍历的顺序访问每个节点。</li><li><strong>处理节点</strong>：当不能再向左遍历时，从栈中弹出一个节点进行处理。这个节点是当前中序遍历序列中的下一个节点。此时检查这个节点的值是否大于 <code>prev</code> 节点的值。如果不是（即当前节点的值小于等于 <code>prev</code> 节点的值），说明这不是一个有效的BST，返回 <code>false</code>。</li><li><strong>转向右子树</strong>：处理完当前节点后，转向右子树并继续迭代过程。</li><li><strong>完成遍历</strong>：当所有节点都被正确处理且没有发现违反BST性质的情况时，遍历结束，返回 <code>true</code>。</li></ol><p>通过这种方法，算法首先访问最左侧的节点（最深的左子树），然后回到其父节点（根节点），最后处理右子树。这正好符合中序遍历的顺序（左-根-右）。使用栈来存储未来将要访问的节点，从而实现了迭代遍历，而不是使用递归。</p><h2 id="代码展示-2" tabindex="-1"><a class="header-anchor" href="#代码展示-2" aria-hidden="true">#</a> 代码展示</h2><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isValidBST</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">TreeNode</span> prev <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 用于记录中序遍历过程中的前一个节点</span>
    <span class="token class-name">Deque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">&gt;</span></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">TreeNode</span> current <span class="token operator">=</span> root<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>current <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 尽可能地向左遍历，并将沿途的节点压入栈</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>current <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>
            current <span class="token operator">=</span> current<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// 当到达最左侧节点后，弹出并处理节点</span>
        current <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>prev <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> current<span class="token punctuation">.</span>val <span class="token operator">&lt;=</span> prev<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        prev <span class="token operator">=</span> current<span class="token punctuation">;</span>

        <span class="token comment">// 转向右子树</span>
        current <span class="token operator">=</span> current<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>时间复杂度：O(n)，其中 n 是二叉树的节点数。每一个节点恰好被遍历一次。</p><p>空间复杂度：O(h)，其中h是树的高度。在最坏的情况下，栈中可能需要存储与树的高度相当数量的节点。对于一棵平衡二叉树，空间复杂度是O(log n)，而对于非平衡二叉树，最坏情况下的空间复杂度可能达到O(n)。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>二叉搜索树是一个有序树，在中序遍历下其输出的是一个递增序列。</p>`,45),l=[c];function i(u,r){return s(),a("div",null,l)}const k=n(t,[["render",i],["__file","98.yanzhengerchasousuoshu.html.vue"]]);export{k as default};
